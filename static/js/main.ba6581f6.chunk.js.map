{"version":3,"sources":["img/smoke.png","Rain.js","serviceWorker.js","index.js"],"names":["module","exports","Rain","useRef","React","useEffect","useState","mount","isAnimating","setAnimating","controls","frameId","width","current","clientWidth","height","clientHeight","scene","THREE","camera","renderer","antialias","geometry","material","color","cube","fog","setClearColor","position","z","rotation","x","y","ambient","directionalLight","flash","set","add","rainGeo","rainDrop","rainMaterial","rain","texture","load","cloudTexture","cloudMaterial","map","transparent","cloudGeo","cloudParticles","p","cloud","Math","random","opacity","push","setSize","i","velocity","vertices","size","renderScene","render","handleResize","aspect","updateProjectionMatrix","animate","forEach","verticesNeedUpdate","power","window","requestAnimationFrame","start","stop","cancelAnimationFrame","appendChild","domElement","addEventListener","removeEventListener","removeChild","remove","dispose","className","ref","onClick","ReactDOM","document","getElementById","Boolean","location","hostname","match","Container","state","isMounted","Component","rootElement","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.ba6581f6.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/smoke.a7987bab.png\";","import React, { Component } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport * as THREE from 'three';\r\nimport cloudTexture from './img/smoke.png';\r\n\r\nconst Rain = () => {\r\n  const { useRef, useEffect, useState } = React\r\n  const mount = useRef(null)\r\n  const [isAnimating, setAnimating] = useState(true)\r\n  const controls = useRef(null)\r\n\r\n  useEffect(() => {\r\n    let width = mount.current.clientWidth\r\n    let height = mount.current.clientHeight\r\n    let frameId\r\n\r\n    const scene = new THREE.Scene()\r\n    const camera = new THREE.PerspectiveCamera(75, width / height, 50, 1000)\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true }) //edge smoothing\r\n    const geometry = new THREE.BoxGeometry(1, 1, 1)\r\n    const material = new THREE.MeshBasicMaterial({ color: 0x123456 })\r\n    const cube = new THREE.Mesh(geometry, material)\r\n\r\n    scene.fog = new THREE.FogExp2(0x11111f, 0.0022);\r\n    renderer.setClearColor(scene.fog.color);\r\n\r\n\r\n    camera.position.z = 4;\r\n    camera.rotation.x = 1.16;\r\n    camera.rotation.y = -0.12;\r\n    camera.rotation.z = 0.27;\r\n\r\n    const ambient = new THREE.AmbientLight(0x555555);\r\n    const directionalLight = new THREE.DirectionalLight(0xffeedd);\r\n    const flash = new THREE.PointLight(0x062d89, 30, 500, 1.7);\r\n\r\n    directionalLight.position.set(0, 0, 1);\r\n    flash.position.set(200, 300, 100);\r\n\r\n    scene.add(ambient);\r\n    scene.add(directionalLight);\r\n    scene.add(flash);\r\n\r\n    // camera.position.z = 4\r\n    // scene.add(cube)\r\n\r\n    let texture = new THREE.TextureLoader().load(cloudTexture);\r\n    const cloudMaterial = new THREE.MeshLambertMaterial({ map: texture, transparent: true });\r\n    // const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xabcdef, transparent: true })\r\n    const cloudGeo = new THREE.PlaneBufferGeometry(500, 500);\r\n    // const cloud = new THREE.Mesh(cloudGeo, cloudMaterial);\r\n\r\n    let cloudParticles = []\r\n    for (let p = 0; p < 1000; p++) {\r\n      let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);\r\n      cloud.position.set(\r\n        Math.random() * 900 - 500,\r\n        450,\r\n        Math.random() * 800 - 300\r\n      );\r\n      cloud.rotation.x = 1.16;\r\n      cloud.rotation.y = -0.12;\r\n      cloud.rotation.z = Math.random() * 360;\r\n      cloud.material.opacity = 0.6;\r\n      cloudParticles.push(cloud);\r\n      scene.add(cloud);\r\n    }\r\n\r\n    // renderer.setClearColor('#000000')\r\n    renderer.setSize(width, height)\r\n\r\n    let rainGeo, rainDrop, rainMaterial, rain;\r\n\r\n    rainGeo = new THREE.Geometry();\r\n    for (let i = 0; i < 15000; i++) {\r\n      rainDrop = new THREE.Vector3(\r\n        Math.random() * 400 - 200,\r\n        Math.random() * 500 - 250,\r\n        Math.random() * 400 - 200\r\n      );\r\n      rainDrop.velocity = {};\r\n      rainDrop.velocity = 1;\r\n      rainGeo.vertices.push(rainDrop);\r\n    }\r\n    rainMaterial = new THREE.PointsMaterial({\r\n      color: 0xaaaaaa,\r\n      size: 0.1,\r\n      transparent: true\r\n    });\r\n    rain = new THREE.Points(rainGeo, rainMaterial);\r\n    scene.add(rain);\r\n\r\n\r\n\r\n\r\n    // let cloudGeo, cloudMaterial, cloudParticles = [];\r\n\r\n\r\n    // let loader = new THREE.TextureLoader();\r\n    // loader.load(cloudTexture,\r\n    //   function (texture) {\r\n    //     cloudGeo = new THREE.PlaneBufferGeometry(500, 500);\r\n    //     cloudMaterial = new THREE.MeshLambertMaterial({\r\n    //       map: texture,\r\n    //       transparent: true\r\n    //     });\r\n    //     for (let p = 0; p < 25; p++) {\r\n    //       let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);\r\n    //       cloud.position.set(\r\n    //         Math.random() * 800 - 400,\r\n    //         500,\r\n    //         Math.random() * 500 - 450\r\n    //       );\r\n    //       cloud.rotation.x = 1.16;\r\n    //       cloud.rotation.y = -0.12;\r\n    //       cloud.rotation.z = Math.random() * 360;\r\n    //       cloud.material.opacity = 0.6;\r\n    //       cloudParticles.push(cloud);\r\n    //       scene.add(cloud);\r\n    //     }\r\n    //   }\r\n    // );\r\n\r\n\r\n    const renderScene = () => {\r\n      renderer.render(scene, camera)\r\n    }\r\n\r\n    const handleResize = () => {\r\n      width = (mount.current.clientWidth)\r\n      height = mount.current.clientHeight\r\n      renderer.setSize(width, height)\r\n      camera.aspect = width / height\r\n      camera.updateProjectionMatrix()\r\n      renderScene()\r\n    }\r\n\r\n    const animate = () => {\r\n      // cube.rotation.x += 0.01\r\n      // cube.rotation.y += 0.004\r\n\r\n\r\n      cloudParticles.forEach(p => {\r\n        p.rotation.z -= 0.002;\r\n      });\r\n      rainGeo.vertices.forEach(p => {\r\n        p.velocity -= 0.1 + Math.random() * 0.1;\r\n        p.y += p.velocity;\r\n        if (p.y < -200) {\r\n          p.y = 200;\r\n          p.velocity = 0;\r\n        }\r\n      });\r\n      rainGeo.verticesNeedUpdate = true;\r\n      // rain.rotation.y += 0.002;\r\n      if (Math.random() > 0.99 || flash.power > 100) {\r\n        if (flash.power < 100)\r\n          flash.position.set(\r\n            Math.random() * 400,\r\n            300 + Math.random() * 200,\r\n            100\r\n          );\r\n        flash.power = 0 + Math.random() * 500;\r\n      }\r\n      renderer.render(scene, camera);\r\n\r\n      renderScene()\r\n      frameId = window.requestAnimationFrame(animate)\r\n    }\r\n\r\n    const start = () => {\r\n      if (!frameId) {\r\n        frameId = requestAnimationFrame(animate)\r\n      }\r\n    }\r\n\r\n    const stop = () => {\r\n      cancelAnimationFrame(frameId)\r\n      frameId = null\r\n    }\r\n\r\n    mount.current.appendChild(renderer.domElement)\r\n    window.addEventListener('resize', handleResize)\r\n    start()\r\n\r\n    controls.current = { start, stop }\r\n\r\n    return () => {\r\n      stop()\r\n      window.removeEventListener('resize', handleResize)\r\n      mount.current.removeChild(renderer.domElement)\r\n\r\n      scene.remove(cube)\r\n      geometry.dispose()\r\n      material.dispose()\r\n    }\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    if (isAnimating) {\r\n      controls.current.start()\r\n    } else {\r\n      controls.current.stop()\r\n    }\r\n  }, [isAnimating])\r\n\r\n  return <div className=\"vis\" ref={mount} onClick={() => setAnimating(!isAnimating)} />\r\n}\r\n\r\nReactDOM.render(<Rain />, document.getElementById('root'))\r\n\r\nexport default Rain;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport Rain from './Rain';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\n// ReactDOM.render(\r\n//   <React.StrictMode>\r\n//     <App />\r\n//   </React.StrictMode>,\r\n//   document.getElementById('root')\r\n// );\r\n\r\nclass Container extends React.Component {\r\n  state = { isMounted: true };\r\n\r\n  render() {\r\n    // const { isMounted = true } = this.state;\r\n    return (\r\n      <Rain />\r\n      //   <>\r\n      //     <button onClick={() => this.setState(state => ({ isMounted: !state.isMounted }))}>\r\n      //       {isMounted ? \"Unmount\" : \"Mount\"}\r\n      //     </button>\r\n      //     {isMounted && <App />}\r\n      //     {isMounted && <div>Scroll to zoom, drag to rotate</div>}\r\n      //   </>\r\n    )\r\n  }\r\n}\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(<Container />, rootElement);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}